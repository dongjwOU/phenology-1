#+TITLE: Lucas's Phenology LabBook
#+AUTHOR: Lucas Mello Schnorr
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Lucas(L) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

This file refers to the study of phenology.

* 2016-02-23 Validation of gray/black pixels outside of palette's limits

Bruno questionned me about the validity of gray and black pixels. His
concerns rely on the correct interpretation of the images. The idea is
as follows:

- Pixels where Green Average (GA) is below the LOW threshold are gray.
- Pixels where GA is higher than the HIGH threshold are black.
- Remaining pixels where GA is between LOW and HIGH threshold are
  colored according to the quantity of colors in the palette.

So, to try out, I have cropped a large drone image to contain only a
small section of 1024 by 1024 pixels. Then, I have executed, using
this image, the following commands:

#+begin_src sh :results output :session :exports both
# convert to GA images
for i in 33 34 35 36 37 38; do
  ./pga_tiff_palette ./pequeno_entrada_v2_crop.tif ../palette/example.palette 33 $i output_33_${i}.tif;
  ./pga_tiff_palette ./pequeno_entrada_v2_crop.tif ../palette/example.palette $i 38 output_${i}_38.tif;
done
# convert to compressed JPG images
for i in `ls output_*`; do
  convert $i `basename $i .tif`.jpg;
done
# add information about the LOW and HIGH threshold in the images
for i in `ls -1 output_??_??.jpg`; do
  TEXT=`echo $i | cut -d"_" -f2-3 | cut -d"." -f1`;
  convert -fill blue -draw "scale 50,50 text 2,10 '$TEXT'" $i `basename $i .jpg`_text.jpg ;
done
# create the GIF animations
convert -resize 1024x1024 -delay 1/3 \
    output_33_38_text.jpg \
    output_33_37_text.jpg \
    output_33_36_text.jpg \
    output_33_35_text.jpg \
    output_33_34_text.jpg \
    output_33_33_text.jpg \
    output_33_XX.gif

convert -resize 1024x1024 -delay 1/3 \
    output_*_38_text.jpg \
    output_XX_38.gif
#+end_src

Resulting images are here:

https://www.dropbox.com/sh/15rztbpcknrbk8k/AADex-BwFphD7UpuV9Prf6K_a/2016-02-23_Test_Gray_Black_Limits

Resulting GIF animations are here:

https://www.dropbox.com/sh/15rztbpcknrbk8k/AABVV3GkT8idTNR4s9_dwnbFa/2016-02-23_Test_Gray_Black_Limits/GIF?dl=0

In my opinion, the way it is done right now is correct.
* 2016-09-13 Create CPM for =dc_TKY_btp_n=
** Mask creation
I've created a mask with =gimp= and stored it in the following
folder. The mask has been created with gimp. Black areas are not
considered when masking, as the file:README.org indicates.
#+begin_src sh :results output
ls -lh ~/svn/phenology/dc_TKY_btp_n/mask.jpg
#+end_src

#+RESULTS:
: -rw-r--r-- 1 schnorr schnorr 51K Sep 13 14:21 /home/schnorr/svn/phenology/dc_TKY_btp_n/mask.jpg
** Calculating the histograms for all images
Looks like the file:./scripts/pga_csv is not working correctly. It
stills execute and call =pga_hist= correctly with the good mask, but the
CSV generated in the standard output is wrong. Here's a customized
script for this data set.

#+begin_src sh :results output
DIRWITHIMAGES=~/svn/phenology/dc_TKY_btp_n/
for file in $(find ${DIRWITHIMAGES} | grep "jpg$" | sort); do
  echo $file
done | head
#+end_src

#+RESULTS:
#+begin_example
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_100_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_101_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_102_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_103_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_104_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_105_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_106_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_107_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_108_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_109_1203+0900_TKY__btp_n.jpg
#+end_example

So, it looks like the *year* is the second field, while the *sequence* is
the third one of the base filename. So, let's consider that.

#+begin_src sh :results output
MASK=~/svn/phenology/dc_TKY_btp_n/mask.jpg
GRAIN=20
DIRWITHIMAGES=~/svn/phenology/dc_TKY_btp_n/
for file in $(find ${DIRWITHIMAGES} | grep "jpg$" | sort); do
   FILE=`basename $file .jpg`
   YEAR=`echo $FILE | cut -d"_" -f2`
   SEQUENCE=`echo $FILE | cut -d"_" -f3`
   echo "$SEQUENCE,$YEAR,`./b/pga_hist $file $MASK $GRAIN`";
done | head
#+end_src

#+RESULTS:
#+begin_example
100,2005,0,0,0,0,0,198,2649782,712377,57830,1597,25,0,0,0,0,0,0,0,0,0
101,2005,0,0,0,0,0,335,2618647,763818,38778,231,0,0,0,0,0,0,0,0,0,0
102,2005,0,0,0,0,0,2,3366166,55641,0,0,0,0,0,0,0,0,0,0,0,0
103,2005,0,0,0,0,0,415,2621272,758190,41661,271,0,0,0,0,0,0,0,0,0,0
104,2005,0,0,0,0,0,1036,2445733,856557,110928,6917,562,64,12,0,0,0,0,0,0,0
105,2005,0,0,0,0,0,816,2448674,852383,114970,4730,217,18,1,0,0,0,0,0,0,0
106,2005,0,0,0,0,0,18,2656676,734337,30707,71,0,0,0,0,0,0,0,0,0,0
107,2005,0,0,0,0,0,327,2426587,874102,116417,4208,165,3,0,0,0,0,0,0,0,0
108,2005,0,0,0,0,0,125,2476115,836275,107405,1869,20,0,0,0,0,0,0,0,0,0
109,2005,0,0,0,0,0,132,2524490,824063,72277,842,5,0,0,0,0,0,0,0,0,0
#+end_example

Great, it has worked. Now, let's put all this in a file. I'll execute
in a terminal so I can edit this file. Here's exactly what I've
executed in the terminal (copy paste entirely after customizing
paths):

#+BEGIN_EXAMPLE
DATABASE=dc_TKY_btp_n
MASK=~/svn/phenology/dc_TKY_btp_n/mask.jpg
GRAIN=20
DIRWITHIMAGES=~/svn/phenology/dc_TKY_btp_n/
PGA_HIST_LOCATION=./b/pga_hist

{
#
# Generate CSV header
#
FINAL=`echo $GRAIN - 1 | bc`
echo -n "database,sequence,year,"
for j in `seq 0 $FINAL`; do echo -n "X$j,"; done | sed "s/,$//"
echo ""

#
# Call pga_hist for each file, aplying the $MASK
#
for file in $(find ${DIRWITHIMAGES} | grep "jpg$" | grep -v mask | sort); do
   FILE=`basename $file .jpg`
   YEAR=`echo $FILE | cut -d"_" -f2`
   SEQUENCE=`echo $FILE | cut -d"_" -f3`
   echo "$DATABASE,$SEQUENCE,$YEAR,`${PGA_HIST_LOCATION} $file $MASK $GRAIN`";
done
} > dc_TKY_btp_n_grain20_masked.csv
#+END_EXAMPLE

I've commited the =dc_TKY_btp_n_grain20_masked.csv= in the experiments directory.

Let's run the same code with 100 as GRAIN (to obtain a 100-bucket histogram).

#+BEGIN_EXAMPLE
DATABASE=dc_TKY_btp_n
MASK=~/svn/phenology/dc_TKY_btp_n/mask.jpg
GRAIN=100
DIRWITHIMAGES=~/svn/phenology/dc_TKY_btp_n/
PGA_HIST_LOCATION=./b/pga_hist

{
#
# Generate CSV header
#
FINAL=`echo $GRAIN - 1 | bc`
echo -n "database,sequence,year,"
for j in `seq 0 $FINAL`; do echo -n "X$j,"; done | sed "s/,$//"
echo ""

#
# Call pga_hist for each file, aplying the $MASK
#
for file in $(find ${DIRWITHIMAGES} | grep "jpg$" | grep -v mask | sort); do
   FILE=`basename $file .jpg`
   YEAR=`echo $FILE | cut -d"_" -f2`
   SEQUENCE=`echo $FILE | cut -d"_" -f3`
   echo "$DATABASE,$SEQUENCE,$YEAR,`${PGA_HIST_LOCATION} $file $MASK $GRAIN`";
done
} > dc_TKY_btp_n_grain100_masked.csv
#+END_EXAMPLE

100 buckets should sufficient since we can get the GA betweem 30% and
40%, with a resolution of 0.5%.

#+begin_src sh :results output
ls -lh experiments
#+end_src

#+RESULTS:
: total 1.4M
: -rw-r--r-- 1 schnorr schnorr 1.1M Sep 13 16:17 dc_TKY_btp_n_grain100_masked.csv
: -rw-r--r-- 1 schnorr schnorr 309K Sep 13 14:38 dc_TKY_btp_n_grain20_masked.csv
** Creating the CPM
Reading the palette
#+begin_src R :results output :session :exports both
paletteFilename = "palette/example.palette";
palette <- toupper(read.csv(paletteFilename, comment.char="?", header=FALSE)$V1);
palette
#+end_src

#+RESULTS:
:  [1] "#99540F" "#B26F2C" "#CC8E51" "#E5B17E" "#FFD8B2" "#6B990F" "#85B22C"
:  [8] "#A3CC51" "#C3E57E" "#E5FFB2" "#0F6B99" "#2C85B2" "#51A3CC" "#7EC3E5"
: [15] "#B2E5FF" "#260F99" "#422CB2" "#6551CC" "#8F7EE5" "#BFB2FF"

Read the CSV
#+begin_src R :results output :session :exports both
library(reshape);
df <- read.csv("experiments/dc_TKY_btp_n_grain100_masked.csv");
dfm <- melt(df, id.vars=c("database", "sequence", "year"));
dfm$variable <- as.integer(substr(as.character(dfm$variable), 2, 100));
head(dfm);
#+end_src

#+RESULTS:
:       database sequence year variable value
: 1 dc_TKY_btp_n      100 2005        0     0
: 2 dc_TKY_btp_n      101 2005        0     0
: 3 dc_TKY_btp_n      102 2005        0     0
: 4 dc_TKY_btp_n      103 2005        0     0
: 5 dc_TKY_btp_n      104 2005        0     0
: 6 dc_TKY_btp_n      105 2005        0     0

Let's do the plot

#+begin_src R :results output graphics :file img/cpm.jpg :exports both :width 1200 :height 800 :session
lowLimit = 30;
highLimit = 50;
library(ggplot2);
ggplot(dfm[dfm$variable >= lowLimit & 
            dfm$variable < highLimit &
            dfm$value != 0,],
       aes(x = sequence, y = value, fill=as.factor(variable))) +
       geom_bar(stat='identity', width=1) +
       ylim(0,NA) +
       theme_bw() +
       scale_fill_manual(values=palette) +
       theme(legend.position="none") +
       facet_wrap(~year);
#+end_src

#+RESULTS:
[[file:img/cpm.jpg]]

* 2016-09-13 CSV created by Comba
** With 2015.csv file sent by Comba
#+begin_src R :results output :session :exports both
df <- read.csv("~/Downloads/2015.csv");
dfm <- melt(df, id.vars=c("sequence", "year"));
dfm$variable <- as.integer(substr(as.character(dfm$variable), 2, 100));
head(dfm);
#+end_src

#+RESULTS:
:   sequence year variable value
: 1        1 2015        0  4246
: 2        2 2015        0  5392
: 3        3 2015        0  5472
: 4        4 2015        0  5496
: 5        5 2015        0  5047
: 6        6 2015        0  2944


#+begin_src R :results output graphics :file img/comba_2015_cpm.jpg :exports both :width 1200 :height 800 :session
lowLimit = 30;
highLimit = 50;
library(ggplot2);
ggplot(dfm[dfm$variable >= lowLimit & 
            dfm$variable < highLimit &
            dfm$value != 0,], # & dfm$value > 2e+,],
       aes(x = sequence, y = value, fill=as.factor(variable))) +
       geom_bar(stat='identity', width=1) +
       ylim(0,NA) +
       theme_bw() +
       scale_fill_manual(values=palette) +
       theme(legend.position="none") +
       facet_wrap(~year);
#+end_src

#+RESULTS:
[[file:img/comba_2015_cpm.jpg]]
** Trying to reproduce
Problem: histograms are not normalized

The problem was that the mask wasn't in the RGB mode. As already noted
in the file:README.org file, mask and images should be in RGB mode
since it is the only way we know how to read JPG images for now. The
histograms were not normalized because the reading of the mask failed,
causing the rest (masking, histogram calculation) to be wrong.

#+BEGIN_EXAMPLE
DATABASE=dc_TKY_y18_d
MASK=~/svn/phenology/dc_TKY_y18_d/mask1.jpeg
GRAIN=100
DIRWITHIMAGES=~/svn/phenology/dc_TKY_y18_d/
PGA_HIST_LOCATION=./b/pga_hist

{
#
# Generate CSV header
#
FINAL=`echo $GRAIN - 1 | bc`
echo -n "database,sequence,year,"
for j in `seq 0 $FINAL`; do echo -n "X$j,"; done | sed "s/,$//"
echo ""

#
# Call pga_hist for each file, aplying the $MASK
#
for file in $(find ${DIRWITHIMAGES} | grep "jpg$" | grep 2015 | grep -v mask | sort); do
   FILE=`basename $file .jpg`
   YEAR=`echo $FILE | cut -d"_" -f2`
   SEQUENCE=`echo $FILE | cut -d"_" -f3`
   echo "$DATABASE,$SEQUENCE,$YEAR,`${PGA_HIST_LOCATION} $file $MASK $GRAIN`";
done
} > dc_TKY_y18_n_2015_grain100_masked.csv
#+END_EXAMPLE
** Creating the CPM again
#+begin_src R :results output :session :exports both
library(reshape);
df <- read.csv("dc_TKY_y18_n_2015_grain100_masked.csv");
dfm <- melt(df, id.vars=c("database", "sequence", "year"));
dfm$variable <- as.integer(substr(as.character(dfm$variable), 2, 100));
head(dfm);
#+end_src

#+RESULTS:
:       database sequence year variable value
: 1 dc_TKY_y18_d        1 2015        0     0
: 2 dc_TKY_y18_d        2 2015        0     0
: 3 dc_TKY_y18_d        3 2015        0     0
: 4 dc_TKY_y18_d        4 2015        0     0
: 5 dc_TKY_y18_d        5 2015        0     0
: 6 dc_TKY_y18_d        6 2015        0     0

#+begin_src R :results output graphics :file  img/comba_2015_cpm_redo.jpg :exports both :width 1200 :height 800 :session
lowLimit = 30;
highLimit = 50;
library(ggplot2);
ggplot(dfm[dfm$variable >= lowLimit & 
            dfm$variable < highLimit &
            dfm$value != 0,], # & dfm$variable != 33,],
       aes(x = sequence, y = value, fill=as.factor(variable))) +
       geom_bar(stat='identity', width=1) +
       ylim(0,NA) +
       theme_bw() +
       scale_fill_manual(values=palette) +
       theme(legend.position="none") +
       facet_wrap(~year);
#+end_src

#+RESULTS:
[[file:img/comba_2015_cpm_redo.jpg]]
** Identify the problem
Count the number of pixels:
#+begin_src sh :results output
for line in `cat dc_TKY_y18_n_2015_grain100_masked.csv | grep -v database | cut -d, -f4-`
do
  echo $line | sed "s/,/+/g" | bc -l
done | cat -n > x.csv
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
head(df);
#+end_src

#+RESULTS:
:   V1      V2
: 1  1 2966555
: 2  2 2005224
: 3  3 1990250
: 4  4 2024096
: 5  5 2108453
: 6  6 2987872

#+begin_src R :results output graphics :file img/verif_number_of_pixels.png :exports both :width 600 :height 400 :session
df <- read.csv("x.csv", head=F, sep="\t");
ggplot(df, aes(x=V1, y=V2)) + geom_point() + ylim(0,NA) + theme_bw();
#+end_src

#+RESULTS:
[[file:img/verif_number_of_pixels.png]]

The number of pixels is indeed different. I should check the reason in =pga_hist=.
** Problem is fixed, here's the results
Count the number of pixels:
#+begin_src sh :results output
for line in `cat dc_TKY_y18_n_2015_grain100_masked.csv | grep -v database | cut -d, -f4-`
do
  echo $line | sed "s/,/+/g" | bc -l
done | cat -n > x.csv
#+end_src

#+RESULTS:

#+begin_src R :results output graphics :file img/verif_number_of_pixels_after_fix.png :exports both :width 600 :height 400 :session
library(ggplot2);
df <- read.csv("x.csv", head=F, sep="\t");
ggplot(df, aes(x=V1, y=V2)) + geom_point() + ylim(0,NA) + theme_bw();
#+end_src

#+RESULTS:
[[file:img/verif_number_of_pixels_after_fix.png]]

The number of pixels is the same.
* 2016-09-14 One plot for all years
** Transform day of the year + year in a R date type
Each day image is tagged with the year combined with the day of the
year. To read such information into a proper date type in R I do as
follows:
#+begin_src R :results output :session :exports both
as.Date('2016.258', format="%Y.%j");
#+end_src

#+RESULTS:
: [1] "2016-09-14"

For further details, see:
- http://www.stat.berkeley.edu/classes/s133/dates.html
** CSV creation for the three databases
#+begin_src sh :results output
NGRAIN=100
PGA_HIST_LOCATION=./b/pga_hist
DIRWITHDATABASES=~/svn/phenology/

#
# Generate CSV header
#
{
FINAL=`echo $NGRAIN - 1 | bc`
echo -n "database,year,sequence,"
for j in `seq 0 $FINAL`; do echo -n "X$j,"; done | sed "s/,$//"
echo ""

for DATABASE in dc_TKY_btp_n dc_TKY_y18_d dc_TKY_y18bb; do
    MASK=${DIRWITHDATABASES}/${DATABASE}/mask.jpg
    for file in $(find ${DIRWITHDATABASES}/${DATABASE}/ | grep "jpg$" | grep -v mask | sort); do
	      FILE=`basename $file .jpg`
	      YEAR=`echo $FILE | cut -d"_" -f2`
	      SEQUENCE=`echo $FILE | cut -d"_" -f3`
	      echo "$DATABASE,$YEAR,$SEQUENCE,`${PGA_HIST_LOCATION} $file $MASK $NGRAIN`";
    done
done
} > experiments/dc_all_grain100_masked.csv
#+end_src
** Read, create DOY, plot everything
#+begin_src R :results output :session :exports both
library(reshape);
df <- read.csv("experiments/dc_all_grain100_masked.csv");
df$doy <- as.Date(paste(df$year, df$sequence),  format="%Y %j");
df$year <- NULL;
df$sequence <- NULL;
dfm <- melt(df, id.vars=c("database", "doy"));
dfm$variable <- as.integer(substr(as.character(dfm$variable), 2, 100));
head(dfm);
#+end_src

#+RESULTS:
:       database        doy variable value
: 1 dc_TKY_btp_n 2005-04-10        0     0
: 2 dc_TKY_btp_n 2005-04-11        0     0
: 3 dc_TKY_btp_n 2005-04-12        0     0
: 4 dc_TKY_btp_n 2005-04-13        0     0
: 5 dc_TKY_btp_n 2005-04-14        0     0
: 6 dc_TKY_btp_n 2005-04-15        0     0

Now plot it
#+begin_src R :results output graphics :file img/dc_all_grain100_masked.png :exports both :width 600 :height 400 :session
paletteFilename = "palette/example.palette";
palette <- toupper(read.csv(paletteFilename, comment.char="?", header=FALSE)$V1);

lowLimit = 30;
highLimit = 50;
library(ggplot2);
ggplot(dfm[dfm$variable >= lowLimit & 
            dfm$variable < highLimit &
            dfm$value != 0,],
       aes(x = doy, y = value, fill=as.factor(variable))) +
       geom_bar(stat='identity', width=1) +
       ylim(0,NA) +
       theme_bw() +
       scale_fill_manual(values=palette) +
       theme(legend.position="none") +
       facet_wrap(~database, ncol=1);
#+end_src

#+RESULTS:
[[file:img/dc_all_grain100_masked.png]]


Looks like we have a scale issue: the Y scale differs for each
database. That's normal because masks are different. I can free the Y
scale when facetting. That should fix and not undermine the
interpretation since everything is normalized anyway. So here's for
version 2. I also improve other aspects, tick labels, axis labels,
font size.

#+begin_src R :results output graphics :file img/dc_all_grain100_masked_v2.png :exports both :width 1200 :height 800 :session
paletteFilename = "palette/example.palette";
palette <- toupper(read.csv(paletteFilename, comment.char="?", header=FALSE)$V1);

lowLimit = 30;
highLimit = 50;
library(ggplot2);
ggplot(dfm[dfm$variable >= lowLimit & 
            dfm$variable < highLimit &
            dfm$value != 0,],
       aes(x = doy, y = value, fill=as.factor(variable))) +
       geom_bar(stat='identity', width=1) +
       ylim(0,NA) +
       ylab ("Green Average Histogram (per-facet, normalized)") +
       xlab ("Time (each day along the years)") +
       scale_x_date(date_breaks="1 year", date_labels="%Y") +
       theme_bw(base_size=22) +
       scale_fill_manual(values=palette) +
       theme(legend.position="none") +
       facet_wrap(~database, ncol=1, scale="free_y");
#+end_src

#+RESULTS:
[[file:img/dc_all_grain100_masked_v2.png]]

* 2016-09-28 Meeting with Comba and attempt with new palette
The problem is the lack of normalization because I discard data if
there is not enough colors to map to the values.

I just realized I can re-use the previously calculated data. They are
here:
#+begin_src sh :results output
head experiments/dc_all_grain100_masked.csv
#+end_src

#+RESULTS:
#+begin_example
database,year,sequence,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,X18,X19,X20,X21,X22,X23,X24,X25,X26,X27,X28,X29,X30,X31,X32,X33,X34,X35,X36,X37,X38,X39,X40,X41,X42,X43,X44,X45,X46,X47,X48,X49,X50,X51,X52,X53,X54,X55,X56,X57,X58,X59,X60,X61,X62,X63,X64,X65,X66,X67,X68,X69,X70,X71,X72,X73,X74,X75,X76,X77,X78,X79,X80,X81,X82,X83,X84,X85,X86,X87,X88,X89,X90,X91,X92,X93,X94,X95,X96,X97,X98,X99
dc_TKY_btp_n,2005,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,188,3939,95294,766327,1284631,499591,276537,186994,121724,80301,46821,29435,14826,7739,3892,1938,918,408,156,82,33,16,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dc_TKY_btp_n,2005,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,9,326,8584,138093,835451,1169693,466826,284257,203629,138448,90150,47334,24171,9271,3508,1316,512,167,46,14,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dc_TKY_btp_n,2005,102,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,458,61731,1527881,1538384,237712,47153,7563,854,68,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dc_TKY_btp_n,2005,103,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,33,381,10727,180539,934053,1058607,437346,281169,199613,137916,90709,48783,25261,10217,4073,1553,557,195,64,8,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dc_TKY_btp_n,2005,104,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,31,59,228,707,8211,174174,923617,896089,443642,283054,222054,164345,113560,73544,51559,28908,16255,9176,5030,3097,1832,1076,627,285,286,126,81,44,25,17,17,15,11,4,3,2,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dc_TKY_btp_n,2005,105,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,9,37,126,641,5719,133844,907311,949266,452534,283706,217511,159970,114207,76989,54611,30281,16760,8610,4708,2427,1196,642,325,140,117,48,24,16,12,10,5,2,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dc_TKY_btp_n,2005,106,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,2482,90566,937508,1206032,420088,258408,195150,141634,93412,45733,20802,6900,2207,614,184,48,15,4,3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dc_TKY_btp_n,2005,107,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,8,13,44,261,3846,111532,863809,985515,461885,286958,222757,165612,119132,79643,56030,31191,16527,8374,4295,2184,1103,522,267,132,95,40,21,5,4,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
dc_TKY_btp_n,2005,108,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,9,12,103,2325,90606,858745,1061053,463386,278986,205025,151662,116641,83961,56351,28355,13615,6328,2756,1112,488,177,64,28,15,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
#+end_example

Let's first read this in R:

#+begin_src R :results output :session :exports both
library(reshape);
df <- read.csv("experiments/dc_all_grain100_masked.csv");
df$doy <- as.Date(paste(df$year, df$sequence),  format="%Y %j");
df$sequence <- NULL;
dfm <- melt(df, id.vars=c("database", "year", "doy"));
dfm$variable <- as.integer(substr(as.character(dfm$variable), 2, 100));
head(dfm);
#+end_src

#+RESULTS:
:       database year        doy variable value
: 1 dc_TKY_btp_n 2005 2005-04-10        0     0
: 2 dc_TKY_btp_n 2005 2005-04-11        0     0
: 3 dc_TKY_btp_n 2005 2005-04-12        0     0
: 4 dc_TKY_btp_n 2005 2005-04-13        0     0
: 5 dc_TKY_btp_n 2005 2005-04-14        0     0
: 6 dc_TKY_btp_n 2005 2005-04-15        0     0

Great, let's do the plot. Configurations:
- use the ~viridis.palette~ sent by comba
- The low and hig limit should be 0 and 100 because now we have 100
  colors in the palette

Load the palette:
#+begin_src R :results output :session :exports both
paletteFilename = "palette/viridis.palette";
palette <- toupper(read.csv(paletteFilename, comment.char="?", header=FALSE)$V1);
#+end_src

#+RESULTS:

Function to draw a year:

#+begin_src R :results output :session :exports both
library(ggplot2);

plot_year <- function (lowLimit, highLimit, database, year, palette)
{
    ggplot(dfm[dfm$database == database & dfm$year == year ,],
       aes(x = doy, y = value, fill=as.factor(variable))) +
       geom_bar(stat='identity', width=1) +
       ylim(0,NA) +
       theme_bw() +
#       ggtitle(paste(database, year, sep=" ")) +
       scale_fill_manual(values=palette) +
       theme(legend.position="none") +
       xlab(NULL) + ylab(NULL) +
       theme(axis.title.x=element_blank(),
                  axis.text=element_blank(),
                  axis.ticks=element_blank(),
                  panel.grid=element_blank(),
                  panel.border=element_blank());
}
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
database = "dc_TKY_y18_d";
base = "img/"
for (year in 2004:2016) {
   png(paste(base, database, "_", year, ".png", sep=""), width = 1920, height = 1080);
   print(plot_year(0, 100, database, year, palette));
   dev.off();
   pdf(paste(base, database, "_", year, ".pdf", sep=""), width = 19.20, height = 10.80);
   print(plot_year(0, 100, database, year, palette));
   dev.off();
}
#+end_src

#+RESULTS:

PDF crop of everything

#+begin_src sh :results output
cd img
rm dc_TKY_y18_d_*-crop.pdf
for file in $(ls dc_TKY_y18_d_*.pdf); do
  pdfcrop $file
done
#+end_src

#+RESULTS:
#+begin_example
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2004-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2005-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2006-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2007-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2008-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2009-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2010-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2011-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2012-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2013-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2014-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2015-crop.pdf'.
PDFCROP 1.38, 2012/11/02 - Copyright (c) 2002-2012 by Heiko Oberdiek.
==> 1 page written on `dc_TKY_y18_d_2016-crop.pdf'.
#+end_example

* 2016-09-28 Clean-up and mask definition for ~dc_TKY_y18_d~ (two masks)
- wrong images
  - 2015,220 \to 2015,244
- masks
  - 2004,first \to 2013,69  (file:masks/dc_TKY_y18_d_mask_section_1.jpg)
  - 2013,86 \to 2016,239 (file:masks/dc_TKY_y18_d_mask_section_2.jpg)
** CSV creation for the this database (using the two masks)
#+begin_src sh :results output
NGRAIN=100
PGA_HIST_LOCATION=./b/pga_hist
DIRWITHDATABASES=~/svn/phenology/

#
# Generate CSV header
#
{
FINAL=`echo $NGRAIN - 1 | bc`
echo -n "database,year,sequence,"
for j in `seq 0 $FINAL`; do echo -n "X$j,"; done | sed "s/,$//"
echo ""

for DATABASE in dc_TKY_y18_d; do
    MASK=./masks/dc_TKY_y18_d_mask_section_1.jpg
    for file in $(find ${DIRWITHDATABASES}/${DATABASE}/ | grep "jpg$" | grep -v mask | sort); do
	      FILE=`basename $file .jpg`
	      YEAR=`echo $FILE | cut -d"_" -f2`
	      SEQUENCE=`echo $FILE | cut -d"_" -f3`
         if [ "$YEAR" == "2013" ] && [ "$SEQUENCE" ==  "086" ]; then
            MASK=./masks/dc_TKY_y18_d_mask_section_2.jpg
         fi
	      echo "$DATABASE,$YEAR,$SEQUENCE,`${PGA_HIST_LOCATION} $file $MASK $NGRAIN`";
    done
done
} > experiments/dc_TKY_y18_d_with_two_masks.csv
#+end_src
* 2016-09-28 Clean-up and mask definition for ~dc_TKY_btp_n~
** First analysis
- wrong images
  - 2010,231
- masks
  - 2005,first \to 2005,199 (mask1)
  - 2005,200 \to 2009,352 (mask2)
  - 2009,352 \to 2016,240 (mask3)
** Second analysis
- wrong images kept as in [[*First analysis][First analysis]], mask gets the whole image
* 2016-09-28 Clean-up and mask definition for ~dc_TKY_y18bb~
Same approach as in [[*Second analysis][Second analysis]]
