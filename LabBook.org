#+TITLE: Lucas's Phenology LabBook
#+AUTHOR: Lucas Mello Schnorr
#+LATEX_HEADER: \usepackage[margin=2cm,a4paper]{geometry}
#+STARTUP: overview indent
#+TAGS: Lucas(L) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

This file refers to the study of phenology.

* 2016-02-23 Validation of gray/black pixels outside of palette's limits

Bruno questionned me about the validity of gray and black pixels. His
concerns rely on the correct interpretation of the images. The idea is
as follows:

- Pixels where Green Average (GA) is below the LOW threshold are gray.
- Pixels where GA is higher than the HIGH threshold are black.
- Remaining pixels where GA is between LOW and HIGH threshold are
  colored according to the quantity of colors in the palette.

So, to try out, I have cropped a large drone image to contain only a
small section of 1024 by 1024 pixels. Then, I have executed, using
this image, the following commands:

#+begin_src sh :results output :session :exports both
# convert to GA images
for i in 33 34 35 36 37 38; do
  ./pga_tiff_palette ./pequeno_entrada_v2_crop.tif ../palette/example.palette 33 $i output_33_${i}.tif;
  ./pga_tiff_palette ./pequeno_entrada_v2_crop.tif ../palette/example.palette $i 38 output_${i}_38.tif;
done
# convert to compressed JPG images
for i in `ls output_*`; do
  convert $i `basename $i .tif`.jpg;
done
# add information about the LOW and HIGH threshold in the images
for i in `ls -1 output_??_??.jpg`; do
  TEXT=`echo $i | cut -d"_" -f2-3 | cut -d"." -f1`;
  convert -fill blue -draw "scale 50,50 text 2,10 '$TEXT'" $i `basename $i .jpg`_text.jpg ;
done
# create the GIF animations
convert -resize 1024x1024 -delay 1/3 \
    output_33_38_text.jpg \
    output_33_37_text.jpg \
    output_33_36_text.jpg \
    output_33_35_text.jpg \
    output_33_34_text.jpg \
    output_33_33_text.jpg \
    output_33_XX.gif

convert -resize 1024x1024 -delay 1/3 \
    output_*_38_text.jpg \
    output_XX_38.gif
#+end_src

Resulting images are here:

https://www.dropbox.com/sh/15rztbpcknrbk8k/AADex-BwFphD7UpuV9Prf6K_a/2016-02-23_Test_Gray_Black_Limits

Resulting GIF animations are here:

https://www.dropbox.com/sh/15rztbpcknrbk8k/AABVV3GkT8idTNR4s9_dwnbFa/2016-02-23_Test_Gray_Black_Limits/GIF?dl=0

In my opinion, the way it is done right now is correct.
* 2016-09-13 Create CPM for =dc_TKY_btp_n=
** Mask creation
I've created a mask with =gimp= and stored it in the following
folder. The mask has been created with gimp. Black areas are not
considered when masking, as the file:README.org indicates.
#+begin_src sh :results output
ls -lh ~/svn/phenology/dc_TKY_btp_n/mask.jpg
#+end_src

#+RESULTS:
: -rw-r--r-- 1 schnorr schnorr 51K Sep 13 14:21 /home/schnorr/svn/phenology/dc_TKY_btp_n/mask.jpg
** Calculating the histograms for all images
Looks like the file:./scripts/pga_csv is not working correctly. It
stills execute and call =pga_hist= correctly with the good mask, but the
CSV generated in the standard output is wrong. Here's a customized
script for this data set.

#+begin_src sh :results output
DIRWITHIMAGES=~/svn/phenology/dc_TKY_btp_n/
for file in $(find ${DIRWITHIMAGES} | grep "jpg$" | sort); do
  echo $file
done | head
#+end_src

#+RESULTS:
#+begin_example
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_100_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_101_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_102_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_103_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_104_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_105_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_106_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_107_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_108_1203+0900_TKY__btp_n.jpg
/home/schnorr/svn/phenology/dc_TKY_btp_n/dc_2005_109_1203+0900_TKY__btp_n.jpg
#+end_example

So, it looks like the *year* is the second field, while the *sequence* is
the third one of the base filename. So, let's consider that.

#+begin_src sh :results output
MASK=~/svn/phenology/dc_TKY_btp_n/mask.jpg
GRAIN=20
DIRWITHIMAGES=~/svn/phenology/dc_TKY_btp_n/
for file in $(find ${DIRWITHIMAGES} | grep "jpg$" | sort); do
   FILE=`basename $file .jpg`
   YEAR=`echo $FILE | cut -d"_" -f2`
   SEQUENCE=`echo $FILE | cut -d"_" -f3`
   echo "$SEQUENCE,$YEAR,`./b/pga_hist $file $MASK $GRAIN`";
done | head
#+end_src

#+RESULTS:
#+begin_example
100,2005,0,0,0,0,0,198,2649782,712377,57830,1597,25,0,0,0,0,0,0,0,0,0
101,2005,0,0,0,0,0,335,2618647,763818,38778,231,0,0,0,0,0,0,0,0,0,0
102,2005,0,0,0,0,0,2,3366166,55641,0,0,0,0,0,0,0,0,0,0,0,0
103,2005,0,0,0,0,0,415,2621272,758190,41661,271,0,0,0,0,0,0,0,0,0,0
104,2005,0,0,0,0,0,1036,2445733,856557,110928,6917,562,64,12,0,0,0,0,0,0,0
105,2005,0,0,0,0,0,816,2448674,852383,114970,4730,217,18,1,0,0,0,0,0,0,0
106,2005,0,0,0,0,0,18,2656676,734337,30707,71,0,0,0,0,0,0,0,0,0,0
107,2005,0,0,0,0,0,327,2426587,874102,116417,4208,165,3,0,0,0,0,0,0,0,0
108,2005,0,0,0,0,0,125,2476115,836275,107405,1869,20,0,0,0,0,0,0,0,0,0
109,2005,0,0,0,0,0,132,2524490,824063,72277,842,5,0,0,0,0,0,0,0,0,0
#+end_example

Great, it has worked. Now, let's put all this in a file. I'll execute
in a terminal so I can edit this file. Here's exactly what I've
executed in the terminal (copy paste entirely after customizing
paths):

#+BEGIN_EXAMPLE
DATABASE=dc_TKY_btp_n
MASK=~/svn/phenology/dc_TKY_btp_n/mask.jpg
GRAIN=20
DIRWITHIMAGES=~/svn/phenology/dc_TKY_btp_n/
PGA_HIST_LOCATION=./b/pga_hist

{
#
# Generate CSV header
#
FINAL=`echo $GRAIN - 1 | bc`
echo -n "database,sequence,year,"
for j in `seq 0 $FINAL`; do echo -n "X$j,"; done | sed "s/,$//"
echo ""

#
# Call pga_hist for each file, aplying the $MASK
#
for file in $(find ${DIRWITHIMAGES} | grep "jpg$" | grep -v mask | sort); do
   FILE=`basename $file .jpg`
   YEAR=`echo $FILE | cut -d"_" -f2`
   SEQUENCE=`echo $FILE | cut -d"_" -f3`
   echo "$DATABASE,$SEQUENCE,$YEAR,`${PGA_HIST_LOCATION} $file $MASK $GRAIN`";
done
} > dc_TKY_btp_n_grain20_masked.csv
#+END_EXAMPLE

I've commited the =dc_TKY_btp_n_grain20_masked.csv= in the experiments directory.

Let's run the same code with 100 as GRAIN (to obtain a 100-bucket histogram).

#+BEGIN_EXAMPLE
DATABASE=dc_TKY_btp_n
MASK=~/svn/phenology/dc_TKY_btp_n/mask.jpg
GRAIN=100
DIRWITHIMAGES=~/svn/phenology/dc_TKY_btp_n/
PGA_HIST_LOCATION=./b/pga_hist

{
#
# Generate CSV header
#
FINAL=`echo $GRAIN - 1 | bc`
echo -n "database,sequence,year,"
for j in `seq 0 $FINAL`; do echo -n "X$j,"; done | sed "s/,$//"
echo ""

#
# Call pga_hist for each file, aplying the $MASK
#
for file in $(find ${DIRWITHIMAGES} | grep "jpg$" | grep -v mask | sort); do
   FILE=`basename $file .jpg`
   YEAR=`echo $FILE | cut -d"_" -f2`
   SEQUENCE=`echo $FILE | cut -d"_" -f3`
   echo "$DATABASE,$SEQUENCE,$YEAR,`${PGA_HIST_LOCATION} $file $MASK $GRAIN`";
done
} > dc_TKY_btp_n_grain100_masked.csv
#+END_EXAMPLE

100 buckets should sufficient since we can get the GA betweem 30% and
40%, with a resolution of 0.5%.

#+begin_src sh :results output
ls -lh experiments
#+end_src

#+RESULTS:
: total 1.4M
: -rw-r--r-- 1 schnorr schnorr 1.1M Sep 13 16:17 dc_TKY_btp_n_grain100_masked.csv
: -rw-r--r-- 1 schnorr schnorr 309K Sep 13 14:38 dc_TKY_btp_n_grain20_masked.csv
** Creating the CPM
Reading the palette
#+begin_src R :results output :session :exports both
paletteFilename = "palette/example.palette";
palette <- toupper(read.csv(paletteFilename, comment.char="?", header=FALSE)$V1);
palette
#+end_src

#+RESULTS:
:  [1] "#99540F" "#B26F2C" "#CC8E51" "#E5B17E" "#FFD8B2" "#6B990F" "#85B22C"
:  [8] "#A3CC51" "#C3E57E" "#E5FFB2" "#0F6B99" "#2C85B2" "#51A3CC" "#7EC3E5"
: [15] "#B2E5FF" "#260F99" "#422CB2" "#6551CC" "#8F7EE5" "#BFB2FF"

Read the CSV
#+begin_src R :results output :session :exports both
library(reshape);
df <- read.csv("experiments/dc_TKY_btp_n_grain100_masked.csv");
dfm <- melt(df, id.vars=c("database", "sequence", "year"));
dfm$variable <- as.integer(substr(as.character(dfm$variable), 2, 100));
head(dfm);
#+end_src

#+RESULTS:
:       database sequence year variable value
: 1 dc_TKY_btp_n      100 2005        0     0
: 2 dc_TKY_btp_n      101 2005        0     0
: 3 dc_TKY_btp_n      102 2005        0     0
: 4 dc_TKY_btp_n      103 2005        0     0
: 5 dc_TKY_btp_n      104 2005        0     0
: 6 dc_TKY_btp_n      105 2005        0     0

Let's do the plot

#+begin_src R :results output graphics :file img/cpm.jpg :exports both :width 1200 :height 800 :session
lowLimit = 30;
highLimit = 50;
library(ggplot2);
ggplot(dfm[dfm$variable >= lowLimit & 
            dfm$variable < highLimit &
            dfm$value != 0,],
       aes(x = sequence, y = value, fill=as.factor(variable))) +
       geom_bar(stat='identity', width=1) +
       ylim(0,NA) +
       theme_bw() +
       scale_fill_manual(values=palette) +
       theme(legend.position="none") +
       facet_wrap(~year);
#+end_src

#+RESULTS:
[[file:img/cpm.jpg]]

* 2016-09-13 CSV created by Comba
** With 2015.csv file sent by Comba
#+begin_src R :results output :session :exports both
df <- read.csv("~/Downloads/2015.csv");
dfm <- melt(df, id.vars=c("sequence", "year"));
dfm$variable <- as.integer(substr(as.character(dfm$variable), 2, 100));
head(dfm);
#+end_src

#+RESULTS:
:   sequence year variable value
: 1        1 2015        0  4246
: 2        2 2015        0  5392
: 3        3 2015        0  5472
: 4        4 2015        0  5496
: 5        5 2015        0  5047
: 6        6 2015        0  2944


#+begin_src R :results output graphics :file img/comba_2015_cpm.jpg :exports both :width 1200 :height 800 :session
lowLimit = 30;
highLimit = 50;
library(ggplot2);
ggplot(dfm[dfm$variable >= lowLimit & 
            dfm$variable < highLimit &
            dfm$value != 0,], # & dfm$value > 2e+,],
       aes(x = sequence, y = value, fill=as.factor(variable))) +
       geom_bar(stat='identity', width=1) +
       ylim(0,NA) +
       theme_bw() +
       scale_fill_manual(values=palette) +
       theme(legend.position="none") +
       facet_wrap(~year);
#+end_src

#+RESULTS:
[[file:img/comba_2015_cpm.jpg]]
** Trying to reproduce
Problem: histograms are not normalized

The problem was that the mask wasn't in the RGB mode. As already noted
in the file:README.org file, mask and images should be in RGB mode
since it is the only way we know how to read JPG images for now. The
histograms were not normalized because the reading of the mask failed,
causing the rest (masking, histogram calculation) to be wrong.

#+BEGIN_EXAMPLE
DATABASE=dc_TKY_y18_d
MASK=~/svn/phenology/dc_TKY_y18_d/mask1.jpeg
GRAIN=100
DIRWITHIMAGES=~/svn/phenology/dc_TKY_y18_d/
PGA_HIST_LOCATION=./b/pga_hist

{
#
# Generate CSV header
#
FINAL=`echo $GRAIN - 1 | bc`
echo -n "database,sequence,year,"
for j in `seq 0 $FINAL`; do echo -n "X$j,"; done | sed "s/,$//"
echo ""

#
# Call pga_hist for each file, aplying the $MASK
#
for file in $(find ${DIRWITHIMAGES} | grep "jpg$" | grep 2015 | grep -v mask | sort); do
   FILE=`basename $file .jpg`
   YEAR=`echo $FILE | cut -d"_" -f2`
   SEQUENCE=`echo $FILE | cut -d"_" -f3`
   echo "$DATABASE,$SEQUENCE,$YEAR,`${PGA_HIST_LOCATION} $file $MASK $GRAIN`";
done
} > dc_TKY_y18_n_2015_grain100_masked.csv
#+END_EXAMPLE
** Creating the CPM again
#+begin_src R :results output :session :exports both
library(reshape);
df <- read.csv("dc_TKY_y18_n_2015_grain100_masked.csv");
dfm <- melt(df, id.vars=c("database", "sequence", "year"));
dfm$variable <- as.integer(substr(as.character(dfm$variable), 2, 100));
head(dfm);
#+end_src

#+RESULTS:
:       database sequence year variable value
: 1 dc_TKY_y18_d        1 2015        0     0
: 2 dc_TKY_y18_d        2 2015        0     0
: 3 dc_TKY_y18_d        3 2015        0     0
: 4 dc_TKY_y18_d        4 2015        0     0
: 5 dc_TKY_y18_d        5 2015        0     0
: 6 dc_TKY_y18_d        6 2015        0     0

#+begin_src R :results output graphics :file  img/comba_2015_cpm_redo.jpg :exports both :width 1200 :height 800 :session
lowLimit = 30;
highLimit = 50;
library(ggplot2);
ggplot(dfm[dfm$variable >= lowLimit & 
            dfm$variable < highLimit &
            dfm$value != 0,], # & dfm$variable != 33,],
       aes(x = sequence, y = value, fill=as.factor(variable))) +
       geom_bar(stat='identity', width=1) +
       ylim(0,NA) +
       theme_bw() +
       scale_fill_manual(values=palette) +
       theme(legend.position="none") +
       facet_wrap(~year);
#+end_src

#+RESULTS:
[[file:img/comba_2015_cpm_redo.jpg]]
** Identify the problem
Count the number of pixels:
#+begin_src sh :results output
for line in `cat dc_TKY_y18_n_2015_grain100_masked.csv | grep -v database | cut -d, -f4-`
do
  echo $line | sed "s/,/+/g" | bc -l
done | cat -n > x.csv
#+end_src

#+RESULTS:

#+begin_src R :results output :session :exports both
head(df);
#+end_src

#+RESULTS:
:   V1      V2
: 1  1 2966555
: 2  2 2005224
: 3  3 1990250
: 4  4 2024096
: 5  5 2108453
: 6  6 2987872

#+begin_src R :results output graphics :file img/verif_number_of_pixels.png :exports both :width 600 :height 400 :session
df <- read.csv("x.csv", head=F, sep="\t");
ggplot(df, aes(x=V1, y=V2)) + geom_point() + ylim(0,NA) + theme_bw();
#+end_src

#+RESULTS:
[[file:img/verif_number_of_pixels.png]]

The number of pixels is indeed different. I should check the reason in =pga_hist=.
** Problem is fixed, here's the results
Count the number of pixels:
#+begin_src sh :results output
for line in `cat dc_TKY_y18_n_2015_grain100_masked.csv | grep -v database | cut -d, -f4-`
do
  echo $line | sed "s/,/+/g" | bc -l
done | cat -n > x.csv
#+end_src

#+RESULTS:

#+begin_src R :results output graphics :file img/verif_number_of_pixels_after_fix.png :exports both :width 600 :height 400 :session
library(ggplot2);
df <- read.csv("x.csv", head=F, sep="\t");
ggplot(df, aes(x=V1, y=V2)) + geom_point() + ylim(0,NA) + theme_bw();
#+end_src

#+RESULTS:
[[file:img/verif_number_of_pixels_after_fix.png]]

The number of pixels is the same.
